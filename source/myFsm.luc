module myFsm (
    input clk,  // clock
    input rst,  // reset
    input up,   // up button
    input down, // down button
    input left, // left button
    output a,
    input aM,
    output b,
    input bM,
    output cin,
    input cinM,
    input sum,
    input cout,
    
    output error // to test for error inputs
  ) {
  
  
  .clk(clk) {
    edge_detector edge_detector(#RISE(1), #FALL(0)); //edge detector to detect rising edge of state_changer
    .rst(rst) {
      fsm state = {MANUAL, AUTO, TEST, A, B, AB, CIN, AC, BC, ABC, FAILED};
      dff counter[28]; // 28 bits flip-flop name counter
    }
  }

  always {
    error = 0;
    a = 0;
    b = 0;
    cin = 0;    
    counter.d = counter.q + 1;
    edge_detector.in = counter.q[27];
    
    case(state.q){
      state.MANUAL:
        counter.d = 0;
        a = aM;
        b = bM;
        cin = cinM;
        if (left){
          state.d = state.AUTO;
        }
        else {
          state.d = state.MANUAL;
        }
      state.AUTO:
        a = counter.q[23];
        b = counter.q[23];
        cin = counter.q[23];
        if (up){
          state.d = state.MANUAL;
        }else {
          if (down){
            counter.d = 0;
            state.d = state.TEST;
          }else {
            state.d = state.AUTO;
          }
        }
      state.FAILED:
        error = 1;
        if (left){
          state.d = state.TEST;
        }else {
          if (up){
            state.d = state.MANUAL;
          }else {
            state.d = state.FAILED;
          }
        }
      
      state.TEST:
        if (edge_detector.out){
          counter.d = 0;
          
          if (sum == 0 && cout == 0){   
            a = 1;
            b = 0;
            cin = 0; 
            state.d = state.A;   
          }else {
          state.d = state.FAILED;
          }
        }else {
          state.d = state.TEST;
        }
        
      state.A:
        if (edge_detector.out){
          if (sum == 0){
            state.d = state.FAILED;
          } else {
              counter.d = 0;
              a = 0;
              b = 1;
              cin = 0;
              state.d = state.B;
          }
        } else {
            state.d = state.A;
        }
      state.B:
        if (edge_detector.out){
          if (sum == 0){
          state.d = state.FAILED;
          } else {
            counter.d = 0;
            a = 1;
            b = 1;
            cin = 0;
            state.d = state.AB;
          }
        } else {
          state.d = state.B;
        }
      state.AB:
        if (edge_detector.out){
          if (cout == 0){
          state.d = state.FAILED;
          } else {
            counter.d = 0;
            a = 0;
            b = 0;
            cin = 1;
            state.d = state.CIN;
          }
        } else {
          state.d = state.AB;
        }
      state.CIN:
        if (edge_detector.out){
          if (sum == 0){
          state.d = state.FAILED;
          } else {
            counter.d = 0;
            a = 1;
            b = 0;
            cin = 1;
            state.d = state.AC;
          }
        } else {
          state.d = state.CIN;
        }
      state.AC:
        if (edge_detector.out){
          if (cout == 0){
          state.d = state.FAILED;
          } else {
            counter.d = 0;

            a = 0;
            b = 1;
            cin = 1;
            state.d = state.BC;
          }
        } else {
          state.d = state.AC;
        }
      state.BC:
        if (edge_detector.out){
          if (cout == 0){
          state.d = state.FAILED;
          } else {
            counter.d = 0;
            a = 1;
            b = 1;
            cin = 1;
            state.d = state.ABC;
          }
        } else {
          state.d = state.BC;
        }
      state.ABC:
        if (edge_detector.out){
          counter.d = 0;
          a = 0;
          b = 0;
          cin = 0;
          state.d = state.AUTO;

        } else {
          state.d = state.ABC;
        }
    }
    
    
  }
}
